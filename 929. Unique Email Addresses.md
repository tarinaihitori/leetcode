1st
時間計算量：O(nm)
空間計算量：O(n)

```python
class Solution:
    def numUniqueEmails(self, emails: List[str]) -> int:
        same_address = set()
        for email in emails:
            local_name, domain_name = email.split("@")
            dots_removed_local_name = local_name.replace(".", "")
            plus_ignored_local_name = dots_removed_local_name.split("+")[0]
            same_address.add(plus_igonored_local_name + "@" + domain_name)
        return len(same_address)
```

2nd
1st を読みやすくする。
local という変数に再代入することも考えたが、
新しい変数を使用することにより、可読性や変数の中身が追いやすいと思い、processed_local という新しい変数を用意した。
split 関数や replace 関数も軽く読んだ。
https://docs.python.org/3.12/library/stdtypes.html#str.split

```python
class Solution:
    def numUniqueEmails(self, emails: List[str]) -> int:
        unique_emails = set()
        for email in emails:
            local, domain = email.split("@")
            local = local.split("+")[0]
            processed_local = local.replace(".", "")
            unique_emails.add(processed_local + "@" + domain)
        return len(unique_emails)
```

RFC のメールアドレスの形式を確認
https://en.wikipedia.org/wiki/Email_address
[RFC5322](https://www.rfc-editor.org/info/rfc5322)と[RFC5321]（https://www.rfc-editor.org/info/rfc5321）を見ると、
ローカルパートでもダブルクォーテーションでくくると、@が使えるため、それも考慮するならメールアドレスのバリデーションをする必要がありそう。
さらに言うと、RFC に準拠していない形式のメールアドレスが来たらどうするなども考慮する必要がある。
例外を投げる、バリデーションして弾くなど。面接ならこのあたりは面接官に聞くと思う。
ただこの関数が使われるユースケースとして考えられるのは、メールの送信時や DB にあるメールアドレスのカウントだと思うので、その場合は例外吐くよりも、そのアドレスは無視して処理を継続したほうが良さそうだなと思った。

@が””でくくられた形でローカル部分に含まれている場合も考慮したコード

```python
class Solution:
    def numUniqueEmails(self, emails):
        """
        与えられたメールアドレスのリストから、正規化後のユニークなメールアドレスの数を返す。
        ローカル部分が引用符で囲まれている場合も考慮する。
        """
        unique_emails = set()

        for email in emails:
            local, domain = self.split_email(email)

            if self.is_quoted(local):
                local_content = local[1:-1]
                normalized_local = local_content
            else:
                local = local.split('+')[0]
                normalized_local = local.replace('.', '')

            normalized_email = normalized_local + '@' + domain

            unique_emails.add(normalized_email)

        return len(unique_emails)

    def split_email(self, email):
        """
        メールアドレスをローカル部分とドメイン部分に分割する。
        ローカル部分が引用符で囲まれている場合、その中の '@' は無視する。
        """
        in_quotes = False
        escape = False
        for i, char in enumerate(email):
            if escape:
                escape = False
                continue
            if char == '\\':
                escape = True
                continue
            if char == '"':
                in_quotes = not in_quotes
                continue
            if char == '@' and not in_quotes:
                return email[:i], email[i+1:]
        # 引用符で囲まれていない '@' が存在しない場合
        return email, ""

    def is_quoted(self, local: str) -> bool:
        """
        ローカル部分が引用符で囲まれているかどうかを判定する。
        """
        return len(local) >= 2 and local.startswith('"') and local.endswith('"')

```

3rd
制約どおりの形式のメールアドレスだけが来ることが確定している前提

```python
from typing import List

class Solution:
    def numUniqueEmails(self, emails: List[str]) -> int:
        unique_emails = set()
        for email in emails:
            local, domain = email.split("@")
            local = local.replace(".", "")
            processed_local = local.split("+")[0]
            unique_emails.add(processed_local + "@" + domain)
        return len(unique_emails)
```
