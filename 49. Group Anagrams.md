1st
アナグラムなので、strs の要素をソートして、それをキーにして辞書に格納すればその値が求めている答えになる。
最初 defaultdict の引数に`([])`としたら、`TypeError: first argument must be callable or None`が出た。
defaultdict の引数は呼び出し可能な関数でなければならず、[]というリテラルはだめらしい。
また関数呼び出しの有無の差でほんの少しリテラルのほうが早いということも分かった。

https://github.com/rihib/leetcode/pull/8#:~:text=Python%E3%81%AB%E3%81%8A%E3%81%91%E3%82%8B%7B%7D,leetcode%2313%20(comment)

https://pylint.readthedocs.io/en/latest/user_guide/messages/refactor/use-list-literal.html
時間計算量：O(n ^ mlogm) strs の長さを n, string の長さを m とする
空間計算量：O(nm)

```python
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        anagrams = defaultdict(list)
        for string in strs:
            sorted_string_list = sorted(string)
            sorted_string = "".join(sorted_string_list)
            anagrams[sorted_string].append(string)
        return list(anagrams.values())
```

2nd
1st を読みやすくする。
主に変数名の変更と、sorted した文字列を変数に入れずにそのまま文字列に変換させた。

```python
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        anagrams = defaultdict(list)
        for word in strs:
            sorted_word = "".join(sorted(word))
            anagrams[sorted_word].append(word)
        return list(anagrams.values())
```

辞書のキーはハッシュ可能なものであれば、文字列でなくてもいいのではないかと思い、イミュータブルな tuple を使った。
https://docs.python.org/3.13/faq/design.html#id22

どちらも計算量的には O(n)だが、.join()はメモリの再割り当てが 1 回で済むように最適化されている？ので、
.join()のほうが定数倍早いのではないかと思う。(CPython の実装を見た)

あとはハッシュ値の計算においても、tuple は各要素への参照を持つため、ハッシュ計算時に各要素のハッシュ値を計算し、それらを組み合わせる必要がある。
そのため join()と比較したときのハッシュ計算時のオーバーヘッドが大きくなる可能性がある。
ただ、そこまで実行時間にシビアになるなら、ほかの言語を使うことを検討するべきだと思う。

https://github.com/python/cpython/blob/2513593303b306cd8273682811d26600651c60e4/Objects/unicodeobject.c#L9969C1-L10031C8
https://github.com/python/cpython/blob/260843df1bd8a28596b9a377d8266e2547f7eedc/Objects/tupleobject.c#L318

ついでに気になったので Python のハッシュ可能なものも軽く調べた。
https://docs.python.org/3/glossary.html#term-hashable

ちなみに dict の.values()はリストではなく、view_object を返す
https://docs.python.org/3/library/stdtypes.html#dict-views

普通の dict を使うと、キーの存在チェックと初期化が必要になるため、defaultdict を使用している。

```python
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        anagrams = defaultdict(list)
        for word in strs:
            anagrams[tuple(sorted(word))].append(word)
        return list(anagrams.values())
```

3rd
ソートした文字列をそのまま結合してキーとして使用するほうが、
タプルを使うよりも直感的でわかりやすいためほぼ 1st と同じ。

```python
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        anagram_pairs = defaultdict(list)
        for word in strs:
            sorted_word = "".join(sorted(word))
            anagram_pairs[sorted_word].append(word)
        return list(anagram_pairs.values())
```
