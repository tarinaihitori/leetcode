1st
時間計算量：O(n)
空間計算量：O(n)
文字列ごとの出現回数を記録し、出現回数が一回のもののインデックスを返す。

```python
class Solution:
    def firstUniqChar(self, s: str) -> int:
        char_to_count = defaultdict(int)
        for char in s:
            char_to_count[char] += 1

        for index, char in enumerate(s):
            if char_to_count[char] == 1:
                return index
        return -1
```

2nd
1st を読みやすいようにする。defaultdict を使わずに通常の辞書を使用した。
気になったので、enumerate 関数の実装も確認した。
https://docs.python.org/ja/3/library/functions.html#enumerate
https://github.com/python/cpython/blob/main/Objects/enumobject.c
通常の range(len(s))を使用して for ループを回す場合、各ループで s[i]のようにインデックスアクセスを行うが、
このとき、s.**getitem**(i)というメソッド呼び出しが内部で行われ、オーバーヘッドが発生する。
一方、enumerate(s)を使用すると、各イテレーションで要素を直接取得できるため、追加のインデックスアクセスが不要になり、その分効率的になる。
個人的には range でも enumerate でも可読性は変わらないと思ったので、より効率的な enumerate を使用したが、どうなんだろうか。
また、戻り値として -1 を返すのではなく、値が存在しないことを明確に示すために Optional 型を使用し、None を返す方が意図がより明確になると考えたため、実務ならそのように実装する。

```python
class Solution:
    def firstUniqChar(self, s: str) -> int:
        char_to_count = {}

        for char in s:
            if char not in char_to_count:
                char_to_count[char] = 0
            char_to_count[char] += 1

        for index, char in enumerate(s):
            if char_to_count[char] == 1:
                return index
        return -1
```

Counter を使用した版

```python
class Solution:
    def firstUniqChar(self, s: str) -> int:
        char_to_count = Counter(s)

        for index, char in enumerate(s):
            if char_to_count[char] == 1:
                return index
        return -1
```

辞書ではなくリストを使った版
この場合、配列を使用しているので、インデックスによるアクセスにより、辞書よりも早くなる可能性がある。
その一方で、（制約では英小文字しかこないが）英小文字以外の文字が来ることも考えると辞書のほうが安全。
あと、`ord(c) - ord('a')`という計算は、一見して理解しづらい可能性がある。
実務で書くなら、汎用性と拡張性を考慮して、辞書を選択すると思う。

過去ログを漁ると、サロゲートペアに言及されていて、Python ではそのあたりどうなんだろうと思い調べてみた。
https://github.com/seal-azarashi/leetcode/pull/15/files
Python 3.3 以降では PEP 393 によってこの問題はほぼ解消されているらしい。
https://peps.python.org/pep-0393/

じゃあ、ウムラウトとかはどうなのかも気になったが、結合文字の場合は別々の文字として認識されるため、
正規化が必要な場合があるとわかった。
今回は制約通り英小文字のみが来ることを想定している。

```python
s = "a\u0308"  # 'a' + '̈'
print(s)         # 出力: ä
print(len(s))    # 出力: 2
```

```python
class Solution:
    def firstUniqChar(self, s: str) -> int:
        freq = [0] * 26
        for c in s:
            freq[ord(c) - ord('a')] += 1
        for i, c in enumerate(s):
            if freq[ord(c) - ord('a')] == 1:
                return i
        return -1
```

3rd

```python
class Solution:
    def firstUniqChar(self, s: str) -> int:
        char_to_counts = {}
        for char in s:
            if char not in char_to_counts:
                char_to_counts[char] = 0
            char_to_counts[char] += 1

        for index, char in enumerate(s):
            if char_to_counts[char] == 1:
                return index
        return -1
```
