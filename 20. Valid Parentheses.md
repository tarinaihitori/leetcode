1st

開き括弧と閉じ括弧のリストを作ることも考えたが、
括弧には対応関係があるため（例えば（」は有効ではない）、括弧の対応関係は辞書で管理する適していると判断。

時間計算量：O(n)
空間計算量：O(n)

```python
class Solution:
    def isValid(self, s: str) -> bool:
        stack = []
        opening_to_closing_parentheses = {"{": "}", "[": "]", "(": ")"}
        for char in s:
            if char in opening_to_closing_parentheses:
                stack.append(char)
            elif char in opening_to_closing_parentheses.values():
                if stack and char == opening_to_closing_parentheses[stack[-1]]:
                    stack.pop()
                else:
                    return False
            else:
                return False
        return not stack
```

2nd
1st を読みやすくする。elif のところで if 文がネストしているので、ここを解消した。
最初、stack という名前が微妙かなと思ったが、
よくよく考えてみると今回は純粋にスタックとして利用しているため逆に分かりやすいと思い変更せず。

```python
class Solution:
    def isValid(self, s: str) -> bool:
        stack = []
        opening_to_closing_parentheses = {"{":"}", "[":"]", "(":")"}
        for char in s:
            if char in opening_to_closing_parentheses:
                stack.append(char)
            elif stack and char == opening_to_closing_parentheses[stack[-1]]:
                stack.pop()
            else:
                return False
        return not stack
```

過去ログや他の人の解法を漁る。

https://discord.com/channels/1084280443945353267/1201211204547383386/1202541275115425822

を見ると、チョムスキー階層、プッシュダウンオートマトンという知らない用語がでていたので、これも調べておく。

- [チョムスキー階層](https://en.wikipedia.org/wiki/Chomsky_hierarchy)

- [プッシュダウンオートマトン](https://en.wikipedia.org/wiki/Pushdown_automaton)

---

stack として使うならリスト以外に、deque も使える。
リストと比べての deque のプロコンなら以下のような感じ

deque の pros

- 先頭への挿入、削除も定数時間で行われる

deque の cons

- 先頭、末端以外への要素のアクセスが要素数に比例する
- 組み込み型ではないので import が必要

結論、今回の場合だと純粋にスタックとしての利用で、先頭への挿入・削除がないのでリストでよさそう（deque の実装はしてみる）
https://docs.python.org/3/library/collections.html#deque-objects
https://github.com/python/cpython/blob/834ba5aaf21ac7fd123534dae8f9e478ee526aaa/Modules/_collectionsmodule.c#L134

```python
# leetcodeだとdequeはデフォルトでimportされているためimportは省略
class Solution:
    def isValid(self, s: str) -> bool:
        stack = deque()
        opening_to_closing_parentheses = {"{":"}", "[":"]", "(":")"}
        for char in s:
            if char in opening_to_closing_parentheses:
                stack.append(char)
            elif stack and char == opening_to_closing_parentheses[stack[-1]]:
                stack.pop()
            else:
                return False
        return not stack
```

else がなくても書けるが、条件に一致しない括弧の対応が発見され次第処理が終わるので、else があると少し早くなるか。
一応 else を省略したコードも書いておく。

```python
class Solution:
    def isValid(self, s: str) -> bool:
        stack = []
        opening_to_closing_parentheses = {"{":"}", "[":"]", "(":")"}
        for char in s:
            if char in opening_to_closing_parentheses:
                stack.append(char)
            elif stack and char == opening_to_closing_parentheses[stack[-1]]:
                stack.pop()
        return not stack
```

3rd

```python
class Solution:
    def isValid(self, s: str) -> bool:
        stack = []
        opening_to_closing_parentheses = {"{":"}", "[":"]", "(":")"}
        for char in s:
            if char in opening_to_closing_parentheses:
                stack.append(char)
            elif stack and char == opening_to_closing_parentheses[stack[-1]]:
                stack.pop()
            else:
                return False
        return not stack
```
