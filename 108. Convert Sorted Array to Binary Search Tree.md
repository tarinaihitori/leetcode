1st
時間計算量：O(n)
空間計算量：O(n) バランスしていれば O(logn)

```python
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:
        if not nums:
            return None

        mid = len(nums) // 2

        balanced_tree = TreeNode(nums[mid])
        balanced_tree.left = self.sortedArrayToBST(nums[:mid])
        balanced_tree.right = self.sortedArrayToBST(nums[mid+1:])

        return balanced_tree
```

2nd
1st を読みやすくする。
再帰のベースケースで配列が空の時であることが明確になるようにした。
再帰がシンプルで読みやすい。スタックオーバーフローが問題なければ、個人的には再帰で書く。

```python
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:
        if len(nums) == 0:
            return
        mid = len(nums) // 2

        root_node = TreeNode(nums[mid])
        root_node.left = self.sortedArrayToBST(nums[:mid])
        root_node.right = self.sortedArrayToBST(nums[mid+1:])

        return root_node
```

iterative な解法
再帰の比べて、かなりコードが複雑になる。
スタックオーバーフローが発生するなら、反復的に書くかな。
時間計算量：O(n)
空間計算量：O(n) バランスしていれば O(logn)

```python
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:
        if not nums:
            return None

        mid = len(nums) // 2
        root = TreeNode(nums[mid])

        node_ranges = [(root, 0, mid, len(nums) - 1)]
        while node_ranges:
            node, left, mid, right = node_ranges.pop()

            if left <= mid - 1:
                left_mid = (left + mid - 1) // 2
                node.left = TreeNode(nums[left_mid])
                node_ranges.append((node.left, left, left_mid, mid - 1))

            if mid + 1 <= right:
                right_mid = (mid + 1 + right) // 2
                node.right = TreeNode(nums[right_mid])
                node_ranges.append((node.right, mid + 1, right_mid, right))

        return root
```

BFS で書いた。
この問題では配列を二分割していくため、DFS のほうが自然に思う。
時間計算量：O(n)
空間計算量：O(n)

```python
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:
        if not nums:
            return None

        mid = len(nums) // 2
        root = TreeNode(nums[mid])

        node_queue = deque()
        node_queue.append((root, 0, mid, len(nums) - 1))

        while node_queue:
            node, left, mid, right = node_queue.popleft()

            if left <= mid - 1:
                left_mid = (left + mid - 1) // 2
                node.left = TreeNode(nums[left_mid])
                node_queue.append((node.left, left, left_mid, mid - 1))

            if mid + 1 <= right:
                right_mid = (mid + 1 + right) // 2
                node.right = TreeNode(nums[right_mid])
                node_queue.append((node.right, mid + 1, right_mid, right))

        return root

```

3rd
再帰的な DFS

```python
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:
        if not nums:
            return
        mid = len(nums) // 2

        root_node = TreeNode(nums[mid])
        root_node.left = self.sortedArrayToBST(nums[:mid])
        root_node.right = self.sortedArrayToBST(nums[mid+1:])

        return root_node

```
