1st
Remove Duplicates from Sorted List とほぼ同じだが、重複するものはすべて取り除く必要がある。
ポインタが head からスタートすると head の値が重複しているときに対応できないため、ダミーを用意してダミー.next に head をつなげる。
そうなると、ノードを一つずつたどる用のポインターと、重複のないノードをつなぐ用の 2 つがいる？
時間計算量:O(n)
空間計算量:O(1)

```python
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(0)
        dummy.next = head

        current_node = head
        last_unique_node = dummy

        while current_node:
            if current_node.next and current_node.val == current_node.next.val:
                while current_node.next and current_node.val == current_node.next.val:
                    current_node = current_node.next.next
                last_unique_node.next = current_node.next
            else:
                last_unique_node = last_unique_node.next
            current_node = current_node.next
        return dummy.next
```

2nd
1st 以外で思いついたのは、最初にリストをすべてたどって重複を記録する。その後再度リストをたどって重複があるものを飛ばしていく方法
時間計算量：O(n)
空間計算量：O(n)

```python
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(0)
        dummy.next = head

        current_node = head
        last_unique_node = dummy

        duplicate_values = set()

        while current_node:
            if current_node.next and current_node.val == current_node.next.val:
                duplicate_values.add(current_node.val)
            current_node = current_node.next

        current_node = head

        while current_node:
            if current_node.val in duplicate_values:
                last_unique_node.next = current_node.next
            else:
                last_unique_node = last_unique_node.next
            current_node = current_node.next
        return dummy.next
```

他の人の解法を見た。
https://github.com/rinost081/LeetCode/pull/6/files#r1744911468 の is_duplicate を使う方法を自分でも書いてみる。
この会話がすごく勉強になった。https://github.com/rinost081/LeetCode/pull/6#discussion_r1745298716

```python
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(0, head)
        node = dummy
        while node:
            is_duplicated = False
            while node.next and node.next.next and node.next.val == node.next.next.val:
                is_duplicated = True
                node.next = node.next.next
            if is_duplicated:
                node.next = node.next.next
            else:
                node = node.next
        return dummy.next
```

https://github.com/h1rosaka/arai60/pull/6/files の tail を使った解法。

```python
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(0)
        tail = dummy
        current = head

        while current:
            count = 1
            while current.next and current.val == current.next.val:
                current = current.next
                count += 1

            if count == 1:
                tail.next = current
                tail = tail.next

            current = current.next
        tail.next = None
        return dummy.next
```

再帰の解法。解けなかったので答えを見た。
https://github.com/goto-untrapped/Arai60/pull/42/files#diff-955136daee65dfdfb0d127b8407c9efa23cc6cb7260f7fdbfc6c4ea1d95b990eR59-R78

```python
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if not head or not head.next:
            return head
        if head.next and head.val == head.next.val:
            while head.next and head.val == head.next.val:
                head = head.next
            return self.deleteDuplicates(head.next)
        else:
            head.next = self.deleteDuplicates(head.next)
            return head
```

3rd

```python
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(0)
        dummy.next = head
        node = dummy

        while node:
            if node.next and node.next.next and node.next.val == node.next.next.val:
                while node.next and node.next.next and node.next.val == node.next.next.val:
                    node.next = node.next.next
                node.next = node.next.next
            else:
                node = node.next
        return dummy.next
```
