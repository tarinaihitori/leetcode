1st
queue を用意し、同じレベルの node を queue にいれ、ノードの要素数だけループを回してリストに入れる。
BFS 的な考え方。
時間計算量：O(n)
空間計算量：O(n)

```python
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if root is None:
            return []
        result = []
        queue = deque([(root)])
        while queue:
            same_level_nodes = []
            queue_length = len(queue)
            for _ in range(queue_length):
                node = queue.popleft()
                same_level_nodes.append(node.val)
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            result.append(same_level_nodes)
        return result
```

2nd
1st を読みやすくする

```python
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if root is None:
            return []
        result = []
        nodes_queue = deque([(root)])
        while nodes_queue:
            same_level_nodes = []
            nodes_count = len(nodes_queue)
            for _ in range(nodes_count):
                node = nodes_queue.popleft()
                same_level_nodes.append(node.val)
                if node.left:
                    nodes_queue.append(node.left)
                if node.right:
                    same_level_nodes.append(node.right)
            result.append(same_level_nodes)
        return result
```

再帰的な方法。
node の数が 2000 までなので RecursionError は考慮しなくていい。

```python
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        def traverse_by_level(node, level):
            if node is None:
                return
            while len(result) <= level:
                result.append([])
            result[level].append(node.val)
            traverse_by_level(node.left, level + 1)
            traverse_by_level(node.right, level + 1)

        result = []
        traverse_by_level(root, 0)
        return result
```

3rd

```python
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if root is None:
            return []
        result = []
        nodes_queue = deque([(root)])
        while nodes_queue:
            same_level_nodes = []
            nodes_count = len(nodes_queue)
            for _ in range(nodes_count):
                node = nodes_queue.popleft()
                same_level_nodes.append(node.val)
                if node.left:
                    nodes_queue.append(node.left)
                if node.right:
                    nodes_queue.append(node.right)
            result.append(same_level_nodes)
        return result
```
