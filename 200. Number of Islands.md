1st
思いついたのが島を見つけたら島を再帰的に訪問済みにしその後カウントする方法。
再帰的な DFS。
今回の制約上、m,n は最大で 300 なので、再帰の深さは最大 90,000 になる可能性がある。
python のデフォルトの再帰の深さは 1000 なので、再帰を書くときは気をつける必要がある。
（LeetCode の再帰の深さは 550,000 に設定されているため、RecursionError は今回発生しない）
時間計算量：O(nm)
空間計算量：O(nm)

```python
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        rows = len(grid)
        cols = len(grid[0])
        number_of_islands = 0

        def visit_islands(row, col):
            if not (0 <= row < rows and 0 <= col < cols and grid[row][col] == "1"):
                return None
            grid[row][col] = "visited"
            for x, y in [(1,0), (-1, 0), (0,1), (0, -1)]:
                visit_islands(row + x, col + y)


        for i in range(rows):
            for j in range(cols):
                if grid[i][j] == "1":
                    visit_islands(i, j)
                    number_of_islands += 1
        return number_of_islands
```

2nd
1st を読みやすくする

```python
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        def mark_land_as_visited(row, col):
            if not (0 <= row < rows and 0 <= col < cols and grid[row][col] == LAND):
                return None
            grid[row][col] = VISITED
            directions = [(1,0), (-1, 0), (0, 1), (0, -1)]
            for delta_row, delta_col in directions:
                mark_land_as_visited(row + delta_row, col + delta_col)

        LAND = "1"
        WATER = "0"
        VISITED = "-1" # 訪問済みを−1で管理
        rows = len(grid)
        cols = len(grid[0])
        number_of_islands = 0

        for row in range(rows):
            for col in range(cols):
                if grid[row][col] == LAND:
                    mark_land_as_visited(row, col)
                    number_of_islands += 1
        return number_of_islands
```

再帰的な方法だと RecursionError のおそれがあるので、スタックを用いた DFS で書いた版

```python
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        def mark_island_as_visited(start_row, start_col):
            stack = []
            stack.append([start_row, start_col])
            while stack:
                current_row, current_col = stack.pop()
                if not (0 <= current_row < rows and 0 <= current_col < cols):
                    continue
                if grid[current_row][current_col] != LAND:
                    continue
                grid[current_row][current_col] = VISITED
                for delta_row, delta_col in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                    stack.append([current_row + delta_row, current_col + delta_col])

        LAND = "1"
        WATER = "0"
        VISITED = "-1" # 訪問済みを−1で管理
        rows = len(grid)
        cols = len(grid[0])

        number_of_islands = 0

        for i in range(rows):
            for j in range(cols):
                if grid[i][j] == LAND:
                    mark_island_as_visited(i, j)
                    number_of_islands += 1
        return number_of_islands
```

BFS で書いた版

```python
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        def mark_island_as_visited(row, col):
            queue = deque([(row, col)])
            while queue:
                current_row, current_col = queue.popleft()
                if not (0 <= current_row < rows and 0 <= current_col < cols):
                    continue
                if grid[current_row][current_col] != LAND:
                    continue
                grid[current_row][current_col] = VISITED
                for x, y in [(1,0), (0, 1), (-1, 0), (0, -1)]:
                    queue.append((current_row + x, current_col + y))

        LAND = "1"
        WATER = "0"
        VISITED = "-1" # 訪問済みを−1で管理
        rows = len(grid)
        cols = len(grid[0])
        number_of_islands = 0

        for i in range(rows):
            for j in range(cols):
                if grid[i][j] == LAND:
                    mark_island_as_visited(i, j)
                    number_of_islands += 1
        return number_of_islands
```

他の人の解法やログを見て Union Find でも解けるらしい。
Union Find は名前しか知らなかったので、今回調べた。

> Union-Find（または Disjoint Set Union）は、要素をいくつかのグループ（集合）に分けて管理し、効率的にグループの結合（Union）と所属判定（Find）を行うデータ構造。これにより、異なる要素が同じグループに属するかを高速に判断できる。主にグラフアルゴリズムで、連結成分の判定やクラスターの管理に利用される。

```python
class UnionFind:
    def __init__(self, nodes):
        self.parent = {node: node for node in nodes}

    def find(self, node):
        if self.parent[node] != node:
            self.parent[node] = self.find(self.parent[node])
        return self.parent[node]

    def union(self, node1, node2):
        root1 = self.find(node1)
        root2 = self.find(node2)
        if root1 != root2:
            self.parent[root2] = root1

class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        if not grid:
            return 0
        rows, cols = len(grid), len(grid[0])
        nodes = []
        for i in range(rows):
            for j in range(cols):
                if grid[i][j] == '1':
                    nodes.append((i, j))
        uf = UnionFind(nodes)
        directions = [(0,1), (1,0), (-1,0), (0,-1)]
        for r, c in nodes:
            for dr, dc in directions:
                nr, nc = r + dr, c + dc
                if (nr, nc) in uf.parent:
                    uf.union((r, c), (nr, nc))
        root_set = set()
        for node in nodes:
            root = uf.find(node)
            root_set.add(root)
        return len(root_set)
```

3rd

```python
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        LAND = "1"
        WATER = "0"
        VISITED = "-1"  # 訪問済みを '-1' で管理
        DIRECTIONS = [(1, 0), (-1, 0), (0, 1), (0, -1)]

        def traverse_island(start_row, start_col):
            stack = []
            stack.append([start_row, start_col])
            while stack:
                current_row, current_col = stack.pop()
                if not (0 <= current_row < rows and 0 <= current_col < cols):
                    continue
                if grid[current_row][current_col] != LAND:
                    continue
                grid[current_row][current_col] = VISITED
                for x, y in DIRECTIONS:
                    stack.append([current_row + x, current_col + y])

        rows = len(grid)
        cols = len(grid[0])

        number_of_islands = 0

        for i in range(rows):
            for j in range(cols):
                if grid[i][j] == LAND:
                    traverse_island(i, j)
                    number_of_islands += 1
        return number_of_islands
```
