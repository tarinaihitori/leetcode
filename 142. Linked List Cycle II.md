1st
https://leetcode.com/problems/linked-list-cycle/description/
と同様に、ノードを一つずつ訪れて、すでに訪れたノードがあればそこがサイクルの開始点だとわかる。
時間計算量：O(n)
空間計算量：O(n)

```python
class Solution:
    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        visited = set()
        current = head
        while current:
            if current in visited:
                return current
            visited.add(current)
            current = current.next
        return None
```

2nd
1st の方法を読みやすくする。変数名に node を足してみたが、逆に冗長になった気もする。

```python
class Solution:
    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        visited_nodes = set()
        current_node = head
        while current_node:
            if current_node in visited_nodes:
                return current_node
            visited_nodes.add(current_node)
            current_node = current_node.next
        return None
```

フロイドの循環検出アルゴリズムを使う方法を試したが、ファストがスローに追いついたとき、そこはサイクルの開始点とは限らないよなと思い、手が止まってしまった。
色々調べて、ファストポインターがスロー追いついたとき、一つのポインターを開始点から始め、一つずつたどっていくと、サイクルの開始点で二つのポインターが出会うとわかった。
https://note.com/rhayahi/n/n7fc11c09fec6#U990Z
時間計算量：O(n)
空間計算量：O(1)

```python
class Solution:
    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        slow = head
        fast = head

        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next

            if slow == fast:
                start_point = head
                meeting_point = fast

                while start_point != meeting_point:
                    start_point = start_point.next
                    meeting_point = meeting_point.next
                return start_point
        return None
```

再帰で解く
末尾再帰について調べる。
https://opaupafz2.hatenablog.com/entry/2022/09/17/185036
引き続き再帰の深さは意識しておく
https://github.com/Mike0121/LeetCode/pull/38/files#r1667733807
時間計算量：O(n)
空間計算量：O(n)

```python
class Solution:
    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        def find_cycle_start_node(current, visited):
            if current is None:
                return None
            if current in visited:
                return current
            visited.add(current)
            return find_cycle_start_node(current.next, visited)
        return find_cycle_start_node(head, set())
```

別の関数に切り分けた ver
leetcode で考えると、find_cycle_start_node は detectCycle でしか使用しない関数なので、
再帰で書くなら inner function の形にするかな。

```python
class Solution:
    def find_cycle_start_node(self, current, visited):
            if current is None:
                return None
            if current in visited:
                return current
            visited.add(current)
            return self.find_cycle_start_node(current.next, visited)

    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        return self.find_cycle_start_node(head, set())
```

3rd
2nd の変数名が冗長な気がしたので、1st と同じ

```python
class Solution:
    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        visited = set()
        current = head
        while current:
            if current in visited:
                return current
            visited.add(current)
            current = current.next
        return None
```

4th

```python
class Solution:
    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        visited = set()
        node = head
        while node:
            if node in visited:
                return node
            visited.add(node)
            node = node.next
        return None
```
