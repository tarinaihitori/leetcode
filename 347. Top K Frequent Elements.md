1st
まずは数値ごとの出現頻度を調べた辞書を作る。それを priorityQueue に入れれば判定できそう。
時間計算量：O(nlogn)
空間計算量：O(n)

```python
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        num_to_count = {}
        for num in nums:
            if num in num_to_count:
                num_to_count[num] += 1
            else:
                num_to_count[num] = 0

        min_heap = []
        for num, freq in num_to_count.items():
            heapq.heappush(min_heap, (freq, num))

        while k < len(min_heap):
            heapq.heappop(min_heap)
        return [num for freq, num in min_heap]
```

2nd
1st を読みやすくする。

```python
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        num_to_count = {}
        for num in nums:
            if num not in num_to_count:
                num_to_count[num] = 0
            num_to_count[num] += 1

        count_to_num = []
        for num, frequency in num_to_count.items():
            heapq.heappush(count_to_num, (frequency, num))
        while k < len(count_to_num):
            heapq.heappop(count_to_num)
        return [num for frequency, num in count_to_num]
```

ソートを使う方法

while を使わずに `num_to_freq_list[:k]`とスライスを使用しても書ける。
sort のキーの指定は lambda でも書けるが、PEP8 に従い関数化した。

```python
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        num_to_count = {}
        for num in nums:
            if num not in num_to_count:
                num_to_count[num] = 0
            num_to_count[num] += 1

        def get_frequency(item):
            return item[1]

        num_to_freq_list = [[num, freq] for num, freq in num_to_count.items()]
        sorted_num_to_freq_list = sorted(num_to_freq_list, key=get_frequency, reverse=True)

        while k < len(sorted_num_to_freq_list):
            sorted_num_to_freq_list.pop()
        return [num for num, freq in sorted_num_to_freq_list]
```

他の人の解法を見てバケットソートで解けるらしいとわかったのでバケットソートで解いてみる。
https://github.com/thonda28/leetcode/pull/17
バケットソートは名前を聞いたことがあるが、中身は知らない状態だったのでこの際に調べた。
バケットソートは要素を特定のカテゴリーごとに「バケット」に分けて、
それぞれのバケット内で並び替えをし、最後に結合するアルゴリズム。
今回の場合だと、出現頻度ごとにバケットを作るという考え方が適用できる。
https://en.wikipedia.org/wiki/Bucket_sort
これだと、メモリの無駄が多いので、3rd で辞書を使った方法で書いた。
https://github.com/kagetora0924/leetcode-grind/pull/11/files#r1658626553

```python
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        num_to_count = {}
        for num in nums:
            if num not in num_to_count:
                num_to_count[num] = 0
            num_to_count[num] += 1

        bucket = [[] for _ in range(len(nums) + 1)]

        for num, freq in num_to_count.items():
            bucket[freq].append(num)

        result = []
        for i in range(len(bucket) - 1, 0, -1):
            if bucket[i]:
                result.extend(bucket[i])
            if len(result) >= k:
                return result[:k]
```

クイックセレクトを用いても書けるらしい。
クイックセレクトについては、初耳だったのでこちらも調べた。
クイックセレクトは、リストから「k 番目に小さい要素を見つける」ためのアルゴリズム。ソートは行わない。
https://en.wikipedia.org/wiki/Quickselect
クイックセレクトの実装は見ながら書いたので、4th step の段階でソラで書けるようにしておく。

```python
# randomはimportされているため省略
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        num_to_count = {}
        for num in nums:
            if num not in num_to_count:
                num_to_count[num] = 0
            num_to_count[num] += 1
        count_list = [(num, freq) for num, freq in num_to_count.items()]

        def quickselect(left, right, k_smallest):
            if left == right:
                return

            pivot_index = random.randint(left, right)
            pivot_index = partition(left, right, pivot_index)

            if k_smallest == pivot_index:
                return
            elif k_smallest < pivot_index:
                quickselect(left, pivot_index - 1, k_smallest)
            else:
                quickselect(pivot_index + 1, right, k_smallest)

        def partition(left, right, pivot_index):
            pivot_frequency = count_list[pivot_index][1]
            count_list[pivot_index], count_list[right] = count_list[right], count_list[pivot_index]
            store_index = left

            for i in range(left, right):
                if count_list[i][1] > pivot_frequency:
                    count_list[store_index], count_list[i] = count_list[i], count_list[store_index]
                    store_index += 1

            count_list[right], count_list[store_index] = count_list[store_index], count_list[right]
            return store_index

        n = len(count_list)
        quickselect(0, n - 1, k - 1)

        return [num for num, freq in count_list[:k]]
```

ここまでを振り返るとこの問題は主に 4 通りの解法で解くことができる

- PriorityQueue を用いた方法
- `.sort()`を用いた方法
- バケットソートを用いた方法
- クイックセレクトを用いた方法

それぞれのプロコンは以下のような感じか
PriorityQueue()

- pros
  - k が小さい場合、効率的
- cons
  - k が大きい場合、非効率になる

sort()

- pros
  - 実装がシンプル
- cons
  - 常に配列全体をソートするため無駄が多い
  - n が大きくなるにつれてソートに時間がかかる

バケットソート

- pros
  - 時間計算量が O(n)なので効率的
  - 出現頻度ごとにまとめるという考え方がわかりやすい
- cons
  - 出現頻度が偏っている場合、無駄な空間が生じる（配列ではなく辞書を使えば解決できそう）

クイックセレクト

- pros
  - 平均時間計算量が O(n)で効率的
- cons
  - 実装が複雑

3rd
個人的には最初の heapq かバケットソートが自然にかけた。

```python
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        num_to_count = {}
        for num in nums:
            if num not in num_to_count:
                num_to_count[num] = 0
            num_to_count[num] += 1

        bucket = defaultdict(list)
        for num, frequency in num_to_count.items():
            bucket[frequency].append(num)

        sorted_frequencies = sorted(bucket.keys(), reverse=True)

        result = []
        for freq in sorted_frequencies:
            result.extend(bucket[freq])
            if k <= len(result):
                return result[:k]
```
